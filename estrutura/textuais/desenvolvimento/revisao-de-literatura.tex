\chapter{REVISÃO DE LITERATURA}
\label{chap:fundamentacaoTeorica}

Neste capítulo, são apresentados alguns conceitos e termos utilizados no decorrer do trabalho. 
Os conceitos apresentados tem relação com a construção do sistema. São apresentadas as 
técnicas, arquiteturas e algoritmos disponíveis para solução do problema, assim como as utilizadas no 
desenvolvimento da solução.

As primeiras seções do capítulo abordam os padrões e protocolos disponíveis na literatura que são 
utilizados na construção de \textit{webservices}.  Esses padrões e protocolos 
são conhecidos por facilitar e flexibilizar a integração de sistemas. 
Entre eles destacam-se o \textit{Service Oriented Architecture} (SOA), que é
uma arquitetura que trata os serviços como componentes e visa utilizar 
esses componentes para resolver problemas de negócios complexos através de composição
de serviços. \textit{Representational State Transfer} (REST), que é um estilo arquitetural 
que pode ser utilizado, ou não, para a criação de serviços SOA. O \textit{Simple Object Access Protocol}
(SOAP), que é um protocolo que muitas vezes é comparado ao REST por também servir
para a criação de serviços SOA.

Além disso, nas seções posteriores, o capítulo também apresenta algoritmos que ajudam a 
resolver o problema da seleção de host para migração de VM através de otimização multiobjetivo (MOO). 
Existem vários algoritmos que podem ser utilizados para a resolução desse tipo de problema. 
Neste trabalho, são abordados os algoritmos genéticos (GAs), que fazem parte de um grupo 
maior de algoritmos, chamado algoritmos evolucionários (EAs). 
O conceito de EA também será abordado neste capítulo.

Nas primeiras quatro seções, as ferramentas apresentadas 
estão relacionadas em como é feita a comunicação e disponibilização do serviço. 
E as outras seções estão relacionados ao funcionamento interno, em como solucionar
a seleção dos melhores hosts.

\section{SERVICE ORIENTED ARCHITECTURE (SOA)}
O desenvolvimento de software para um ambiente corporativo é uma tarefa complexa. 
Conforme Brown \cite{brown}, no decorrer dos anos, a comunidade de desenvolvimento de software se 
dedicou em desenvolver novas abordagens, processos e ferramentas para a construção de softwares de 
grande escala. 

Brown considera que uma maneira de descrever um sistema de software é como sendo um composto de 
uma coleção de serviços. Cada serviço, provém um conjunto de funcionalidades bem definidas. 
As funcionalidades do serviço sendo bem definidas tornam possível a construção de serviços 
compostos, ou seja, uma funcionalidade que faça a utilização de outras funcionalidades ou serviços. 
Esta modularização e coordenação de serviços e funcionalidades caracteriza uma 
Service Oriented Architecture (SOA).

Segundo \cite{valipour}, SOA pode ser definido como um design de software utilizado para 
conectar negócios e recursos computacionais sob demanda, e isso possibilita os usuários 
do serviço (podendo ser outros serviços ou usuários finais) a alcançarem seus objetivos. 

Existem diversas maneiras de implementar uma aplicação baseada em SOA, o importante é que 
sua interface seja bem definida com as operações que podem ser realizadas. 
Uma das grandes vantagens do SOA, é a facilidade que ele provém na integração de sistemas. 
Segundo \cite{valipour}, com as operações bem definidas e disponíveis, o consumidor do SOA, 
pode se preocupar somente com o que determinado serviço faz e não como é implementado.

As principais características de um software feito utilizando SOA são que ele é auto contido e 
modular, interoperável, fracamente acoplado, passível de composição e possui transparência de localização. 
Como SOA não limita a estratégia utilizada para o desenvolvimento do mesmo, pode-se utilizar qualquer 
técnica para implementá-lo. No ambiente corporativo, os serviços comumente são implementados 
utilizando web services SOAP, REST ou chamadas RPCs.

\subsection{Enterprise Service Bus (ESB)}

Para obter essa flexibilidade na construção dos serviços, o é comum o SOA utilizar
uma camada que recebe a chamada dos serviços e encaminha para o serviço correto.
Essa camada, além da responsabilidade enfileirar as mensagens enviadas aos serviços,
também faz a tradução da comunicação, caso um serviço trabalhe somente com SOAP e outro somente
com REST.

A arquitetura utilizando SOA fica semelhante a da imagem.

@TODO Montar a imagem do SOA

\section{REPRESENTATIONAL STATE TRANSFER (REST)}
REST foi formalizado por Fielding \cite{fielding} em sua tese de doutorado, onde ele tem por 
objetivo apresentar uma arquitetura para criação de sistemas network-based. 
Na tese, REST é definido como um estilo arquitetural. Fielding também define seis restrições que 
devem ser respeitadas na criação de um software que é implementado utilizando este estilo arquitetural. 



As restrições definidas por Fielding, ou seja, as restrições que um sistema
deve atender quando se está utilizando REST podem ser atendidas em sua totalidade
ou não, isso depede do nível de maturidade da API. Uma API que não atende todas as restrições
não está deixando de utilizar REST, apenas o utiliza com um nível de maturidade
menor. As seis restrições são:

\begin{enumerate}
  \item Interface uniforme
  \item \textit{Stateless}
  \item Cacheável
  \item Cliente-servidor
  \item Sistema em camadas
  \item Código por demanda (Opcional)
\end{enumerate}

\subsection{Interface Uniforme}

Fielding \cite{fielding} destaca que uma das características centrais do REST, e o que difere ele 
de outros estilos arquiteturais, é a utilização de uma interface uniforme entre os componentes. 
Esta interface uniforme define a forma com que o cliente e o servidor se comunicam. Segundo \cite{todd}
isto desacopla e simplifica a arquitetura.

Segundo \cite{todd} além disso, essa interface, é uniforme quando segue as seguintes características:

\begin{enumerate}
  \item Baseada em recurso
  \item Manipula os recursos através de representações
  \item Possui mensagens autodescritivas
  \item \textit{Hypermedia as the Engine of Application State} (HATEOAS)
\end{enumerate}

Ser \textbf{baseada em recursos}, significa que a interface deve separar seus
recursos através de \textit{Universal Resource Identifiers}(URIs). 
Cada recurso possui alguma URI que serve como \textit{endpoint} para interação com o usuário. 
Essa URI é utilizada para fazer a \textbf{manipulação dos recursos utilizando representações}.
As representações de um recursos podem ter diversos formatos, como por exemplo 
\textit{JavaScript Object Notation} (JSON) ou \textit{eXtensible Markup Language}(XML).

\textbf{Mensagens autodescritivas} significa que na requisição feita pelo cliente para
o servidor, devem ser incluidas informações sobre o que deve ser feito com o recurso
que se está utilizando. Por exemplo, deve ser incluido o formato que está sendo feita a
comunicação (XML, JSON), o que está querendo modificar naquele recurso (atualizar, deletar, etc.).
Além dessas informações, que são enviadas pelo cliente, as mensagens de resposta também devem 
ser autodescritivas, contendo informações sobre a resposta, por exemplo, se o recurso pode ser
cacheado e por quanto tempo.

O \textbf{HATEOAS} é utilizado apenas por APIs que tenham um nível de maturidade 
maior. 


\subsection{Stateless}
\subsection{Cacheável}
\subsection{Sistemas em camadas}
\subsection{Código por demanda}
\subsection{Cliente-servidor}

REST é implementado utilizando o modelo de comunicação cliente-servidor. 
Isso ajuda com a separação de responsabilidades, e permite que uma portabilidade 
de clientes do serviço implementado. O REST permite uma reutilização do serviço. 
Do ponto de vista de arquitetura de software, isto é muito importante, pois permite 
que componentes fiquem bem modularizados.

\section{SIMPLE OBJECT ACCESS PROTOCOL (SOAP)}
SOAP é um protocolo de comunicação baseado em XML(eXtension Markup Language) que foi criado no final 
dos anos 90. Seu objetivo é fazer a comunicação entre o cliente e o servidor através de informações 
passadas através de um documento XML. O protocolo utiliza um \textit{schema} XML, que é uma 
maneira de descrever e validar o formato os dados das requisições e respostas. 
Esse \textit{schema} é utilizado pelo cliente e pelo servidor para saber como interpretar 
a resposta, no caso de recebimento de mensagem, e formatar a requisição, no caso de envio.
Esse \textit{schema} é chamado de WSDL (Web Services Description Language).

O objetivo do SOAP, é expor regras de negócio de aplicação através de serviços. 
Por esse motivo, o SOAP é uma opção comumente utilizada na construção de aplicações SOA. 
Outra característica do SOAP, é que ele não precisa ser implementado sobre um protocolo de 
transporte específico, e na maioria das vezes é utilizado HTTP, porém é possível implementá-lo
utilizando outros protocolos. Além do SOAP permitir utilizar outro protocolo, 
ele não restringe a implementação em alguma linguagem de programação específica, ou seja,
é possível implementá-lo em qualquer linguagem de programação.

O SOAP é comparado com ao REST, pois os dois podem ser utilizados para um objetivo 
semelhante, porém, os dois tem um foco diferente, onde o SOAP tem como objetivo expor regras de negócio 
como serviço, e o REST visa representar um determinado estado e manipulá-lo através de operações 
bem definidas.

Segundo \cite{lecheta} como o SOAP é um grande XML, no contexto dos webservices, ele começou
a parder espaço para o REST, o qual é mais simples 
e permite enviar informações em formatos mais leves, como o JSON por exemplo. 
Isso é uma grande vantagem, principalmente por ser um problema
que tem o potencial de ter quantidade de dados trafegando em larga escala.

@TODO Adicionar comparação com o REST

\section{OTIMIZAÇÃO MULTI-OBJETIVO (MOO)}  
Conforme Nos dias de hoje, problemas de otimização buscam um bom resultado.
Segundo Veloso \cite{veloso} para os problemas de otimização, existem de maneira geral, 
dois tipos de problemas, os mono-objetivos e os multi-objetivos. 
Os mono-objetivos buscam otimizar uma solução baseando-se em um único objetivo, por consequência, 
problemas mono-objetivo resultam em um único resultado, que pode ser considerada a solução ótima para o 
problema. Já os multi-objetivo, buscam atender vários fatores, e isso torna a solução ótima mais 
difícil de ser encontrada.

Conforme Ticona \cite{ticona} um problema de otimização multi-objetivo, é representado por um 
conjunto de funções objetivo que devem ser otimizadas. 

Segundo \cite{Hashimoto} num problema multi-objetivo, considera-se um conjunto de 
variávies, que são chamadas de solução, que busca otimizar mais de uma função objetivo 
satisfazendo algumas restrições. 

No universo dos algoritmos de otimização multi-objetivo, existem diversos tipos, e nesse trabalho
será utilizado algoritmos genéticos, os quais fazem parte da classe de algoritmos evolucionários.
Os mesmos serão descritos a seguir nesse capítulo.
 
\section{ALGORITMOS EVOLUCIONÁRIOS (EA)}
Segundo \cite{ticona}, algoritmos evolucionários (AE) tem sido muito utilizados para problemas de 
otimização. Um dos motivos do uso deles, é por causa da possibilidade de resolver problemas que 
envolvam múltiplos objetivos. A abordagem utilizada neste tipo de algoritmo é baseada na 
evolução humana. O processo é baseado seleção natural de Darwin, da mesma maneira que acontece com a 
seleção das espécies. O algoritmo reproduz artificialmente o processo de seleção natural para 
encontrar os mais aptos a resolver determinado problema. O objetivo desses algoritmos é 
encontrar aproximações da solução perfeita para problemas difíceis. 

Dentro da categoria dos AEs para otimização baseada em multiplos objetivos, existem diferentes modelos. 

O modelo de utilizado neste trabalho é a de algoritmos genéticos (AG). Esta é uma classe de 
algoritmos muito utilizada em otimizações multi-objetivo. 

\section{ALGORITMOS GENÉTICOS (GA)}
@TODO

\section{TRABALHOS RELACIONADOS}
Neste capítulo será apresentado o problema em que o OptVM se propõem resolver. 
Isso será feito através da apresentação de alguns fatos relacionados a nuvens computacionais 
e como elas costumam ser utilizadas nos dias de hoje.

\subsection{Migração de máquinas virtuais}
As nuvens computacionais são utilizadas pela maioria das empresas de software da atualidade. 
Por esse motivo, as maiores empresas do setor investem muito neste segmento, 
oferecendo vários tipos de serviços diferenciados para seus consumidores. 
Estas empresas concorrem em alguns aspectos, como: velocidade, preço, disponibilidade e etc. 
Para aumentar sua competitividade nesses aspectos, muitas vezes é utilizada a virtualização.

Com a virtualização é possível alocar partes de um recurso físico para diferentes consumidores, 
fazendo com que um recurso físico se torne melhor utilizado. Isso deixa a alocação de recursos
muito mais flexível, e torna possível obter uma elasticidade nos serviços oferecidos. 

Uma dos objetivos de utilizar a virtualização é obter uma elasticidade dos recursos oferecidos.
Ou seja, é possível aumentar sua capacidade de processamento, armazenamento mesmo depois que o
já foi alocada uma VM para o usuário. 
Isso permite que um consumidor do  serviço possa escolher o quanto precisa para executar as tarefas que deseja, 
assim como o provedor também consegue otimizar o uso de seus recursos

Essa realocação de uma VM pode ser feita a nível de nuvem, datacenter(DC) ou host. 
Quando a realocação é feita em nível de DC ou nuvem, é muito provável que seja 
necessário migrar uma VM do local em que ela se encontra. 
Caso seja necessário uma migração de uma máquina, existem alguns pontos que devem ser avaliados.

Três momentos podem ser considerados os pontos principais a serem avaliados para uma migração, 
são eles:

\begin{enumerate}
\item A descoberta de uma necessidade de migração
\item Qual máquina virtual deve ser mgirada
\item Para onde deve ocorrer a migração
\end{enumerate}

Estas otimizações e migrações das VMs são necessárias em ambientes que envolvem uma infraestruturas
grande, onde existem multiplos hosts, datacenters e nuvens. Por esse motivo, não é recomendado que 
um sistema ou serviço gerencie a infraestrutura inteira sozinho, pois sua escalabilidade 
poderia se tornar um gargalo. Isso faz com que sejam construidos diferentes serviços e aplicações 
que se integram e gerenciam a infraesturua.

\subsection{Otimização na escolha de um host}
Como citado anteriormente uma das partes essenciais na migração de uma VM é a escolha de um destino para ela.
Para isso, é importante escolher um destino que aloque muito bem a VM e não seja necessário fazer uma outra
migração logo em seguida. 
